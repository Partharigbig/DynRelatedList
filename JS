import { LightningElement, api, wire, track } from 'lwc';
import { NavigationMixin } from 'lightning/navigation';
import { encodeDefaultFieldValues } from 'lightning/pageReferenceUtils';
import { ShowToastEvent } from 'lightning/platformShowToastEvent';
import { refreshApex } from '@salesforce/apex';
import { getObjectInfo } from 'lightning/uiObjectInfoApi';
 
import getChildren from '@salesforce/apex/MedicalConditionsMobileCtrl.getChildren';
import getRtId from '@salesforce/apex/MedicalConditionsMobileCtrl.getRecordTypeIdByDeveloperName';
import countChildren from '@salesforce/apex/MedicalConditionsMobileCtrl.countChildren';
 
export default class MedicalRelatedListByRT extends NavigationMixin(LightningElement) {
  @api recordId;
 
  // App Builder props
  @api title = 'Related Records';
  @api childObjectApiName = 'Medical_Conditions__c';
  @api parentLookupFieldApiName = 'Account__c';
  @api recordTypeDeveloperName;
  @api newButtonLabel = 'New';
  @api maxRows = 50;
  @api viewAllTabApiName = 'Medical_View_All';
 
  // fieldsToShow (reactive array for wire)
  _fieldNamesStr = 'Name,Medical_Conditions_Disabilities_Name__c,Allergy_Type__c,Treatment__c,Additional_Notes__c';
  @track fieldApiNames = [];
  @api
  get fieldsToShow() { return this._fieldNamesStr; }
  set fieldsToShow(v) {
    this._fieldNamesStr = v || '';
    this.fieldApiNames = this._fieldNamesStr.split(',').map(s => s.trim()).filter(Boolean);
    this.buildColumns(!!this.objectInfo?.data);
  }
 
  // State
  allRows = [];
  rows = [];
  columns = [];
  totalCount = 0;
  recordTypeId;
  errorMsg;
  lastLoaded = null;
  wiredChildrenResult;
  @track refreshNonce = 0;
 
  // Sorting
  sortedBy = 'Name';
  sortedDirection = 'asc';
 
  // Updated … ago ticker
  @track _nowTick = Date.now();
  _timerId;
 
  // Object metadata + permissions
  canCreate = false;
  canEdit = false;
  _columnsBuiltWithMeta = false;
 
  @wire(getObjectInfo, { objectApiName: '$childObjectApiName' })
  objectInfoWire({ data }) {
    if (data) {
      // Object-level CRUD
      this.canCreate = !!data.createable;
      this.canEdit   = !!data.updateable;
      // Rebuild columns to add/remove action column based on Update
      this.buildColumns(true);
    }
  }
 
  // Computed
  get hasCount() { return (this.totalCount || 0) > 0; }
  get itemCountText() {
    const n = this.totalCount || 0;
    return `${n} item${n === 1 ? '' : 's'}`;
  }
  get updatedAgo() {
    if (!this.lastLoaded) return '';
    const secs = Math.floor((Date.now() - this.lastLoaded) / 1000);
    if (secs < 60) return `${secs}s ago`;
    const mins = Math.floor(secs / 60);
    if (mins < 60) return `${mins} min ago`;
    const hrs = Math.floor(mins / 60);
    return `${hrs} hr ago`;
  }
  get subtitle() {
    const bits = [];
    if (this.hasCount) bits.push(this.itemCountText);
    bits.push('Filtered by Record Type');
    if (this.lastLoaded) bits.push(`Updated ${this.updatedAgo}`);
    return bits.join(' • ');
  }
  get showViewAll() { return this.totalCount > (this.rows?.length || 0); }
  get displayTitle() { return `${this.title} (${this.totalCount || 0})`; }
 
  // Lifecycle
  connectedCallback() {
    if (!this.fieldApiNames.length) {
      this.fieldApiNames = this._fieldNamesStr.split(',').map(s => s.trim()).filter(Boolean);
    }
    this.buildColumns(false); // initial columns
    this._timerId = window.setInterval(() => { this._nowTick = Date.now(); }, 10000);
  }
  disconnectedCallback() {
    if (this._timerId) window.clearInterval(this._timerId);
  }
  renderedCallback() {
    if (this.objectInfo?.data && !this._columnsBuiltWithMeta) {
      this.buildColumns(true);
      this._columnsBuiltWithMeta = true;
    }
  }

// ----- columns (build from field labels via getObjectInfo) -----
buildColumns(useMeta = false) {
  const info = useMeta ? this.objectInfo?.data : null;
 
  const cols = (this.fieldApiNames || []).map((f) => {
    // Prefer real Salesforce field label from metadata; otherwise prettify API name
    const label = info?.fields?.[f]?.label
      ? info.fields[f].label
      : (
          f.endsWith('__c')
            ? f.replace('__c','').replace(/_/g,' ').replace(/^./, c => c.toUpperCase())
            : f
        );
 
    // Make Name clickable, but keep dynamic label
    if (f === 'Name') {
      return {
        label,
        fieldName: 'recordUrl',
        type: 'url',
        typeAttributes: { label: { fieldName: 'Name' }, target: '_blank' },
        cellAttributes: { class: 'slds-text-title_bold slds-text-heading_small' },
        sortable: true
      };
    }
 
    return { label, fieldName: f, type: 'text', sortable: true };
  });
 
  // (Optional) action column — keep only if you gate by canEdit elsewhere
  if (this.canEdit) {
    cols.push({
      type: 'action',
      typeAttributes: { rowActions: [{ label: 'Edit', name: 'edit' }] },
      cellAttributes: { alignment: 'right' }
    });
  }
 
  this.columns = cols;
  this._columnsBuiltWithMeta = !!info;
}
 
  // Wires
  @wire(getRtId, { sobjectApiName: '$childObjectApiName', developerName: '$recordTypeDeveloperName' })
  wiredRt({ data, error }) {
    if (data !== undefined) this.recordTypeId = data || null;
    else if (error) this.errorMsg = 'Record Type lookup failed.';
  }
 
  @wire(countChildren, {
    parentId: '$recordId',
    childObjectApiName: '$childObjectApiName',
    parentLookupFieldApiName: '$parentLookupFieldApiName',
    recordTypeId: '$recordTypeId'
  })
  wiredCount({ data }) {
    if (data !== undefined) this.totalCount = data || 0;
  }
 
  @wire(getChildren, {
    parentId: '$recordId',
    childObjectApiName: '$childObjectApiName',
    parentLookupFieldApiName: '$parentLookupFieldApiName',
    fieldApiNames: '$fieldApiNames',
    recordTypeId: '$recordTypeId',
    limitSize: '$maxRows',
    nonce: '$refreshNonce'
  })
  wiredChildren(result) {
    this.wiredChildrenResult = result;
    const { data, error } = result;
    if (data) {
      this.allRows = data.map(r => ({ ...r, recordUrl: '/' + r.Id }));
      this.sortedBy = 'Name';
      this.sortedDirection = 'asc';
      this.applySort();
      this.errorMsg = undefined;
      this.lastLoaded = Date.now();
      this._nowTick = Date.now();
    } else if (error) {
      this.rows = [];
      this.allRows = [];
      this.errorMsg = 'Could not fetch records.';
    }
  }
 
  // Sorting
  handleSort(event) {
    const clickedField = event.detail.fieldName;
    const field = clickedField === 'recordUrl' ? 'Name' : clickedField;
    let direction = 'asc';
    if (field === this.sortedBy) {
      direction = this.sortedDirection === 'asc' ? 'desc' : 'asc';
    }
    this.sortedBy = field;
    this.sortedDirection = direction;
    this.applySort();
  }
  applySort() {
    const field = this.sortedBy || 'Name';
    const dir = this.sortedDirection === 'desc' ? -1 : 1;
    const clone = [...this.allRows];
    clone.sort((a, b) => {
      const av = (a[field] ?? '').toString().toLowerCase();
      const bv = (b[field] ?? '').toString().toLowerCase();
      if (av === bv) return 0;
      return av > bv ? dir : -dir;
    });
    this.rows = clone;
  }
 
  // Actions
  async handleRefresh() {
    this.refreshNonce = this.refreshNonce + 1;
    if (this.wiredChildrenResult) {
      await refreshApex(this.wiredChildrenResult);
    }
    this.lastLoaded = Date.now();
    this._nowTick = Date.now();
  }
 
  handleNew() {
    // Respect Create permission
    if (!this.canCreate) {
      this.dispatchEvent(new ShowToastEvent({
        title: 'Not permitted',
        message: 'You do not have permission to create this record.',
        variant: 'error'
      }));
      return;
    }
 
    const state = {
      defaultFieldValues: encodeDefaultFieldValues({ [this.parentLookupFieldApiName]: this.recordId })
    };
    if (this.recordTypeId) {
      state.recordTypeId = this.recordTypeId;
    } else if (this.recordTypeDeveloperName) {
      this.dispatchEvent(new ShowToastEvent({
        title: 'Record Type not ready',
        message: 'Please wait a moment and try again.',
        variant: 'warning'
      }));
      return;
    }
 
    this[NavigationMixin.Navigate]({
      type: 'standard__objectPage',
      attributes: { objectApiName: this.childObjectApiName, actionName: 'new' },
      state
    });
  }
 
  handleViewAll() {
    this[NavigationMixin.Navigate]({
      type: 'standard__navItemPage',
      attributes: { apiName: this.viewAllTabApiName },
      state: {
        c__parentId: this.recordId,
        c__childObjectApiName: this.childObjectApiName,
        c__parentLookupFieldApiName: this.parentLookupFieldApiName,
        c__recordTypeDeveloperName: this.recordTypeDeveloperName,
        c__fieldsToShow: this.fieldsToShow,
        c__title: this.title
      }
    });
  }
 
  handleRowAction(event) {
    const actionName = event.detail.action.name;
    const row = event.detail.row;
 
    if (actionName === 'edit') {
      if (!this.canEdit) {
        this.dispatchEvent(new ShowToastEvent({
          title: 'Not permitted',
          message: 'You do not have permission to edit this record.',
          variant: 'error'
        }));
        return;
      }
      this[NavigationMixin.Navigate]({
        type: 'standard__recordPage',
        attributes: {
          recordId: row.Id,
          objectApiName: this.childObjectApiName,
          actionName: 'edit'
        }
      });
    }
  }
}
