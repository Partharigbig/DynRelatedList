import { LightningElement, api, wire, track } from 'lwc';
import { NavigationMixin } from 'lightning/navigation';
import { encodeDefaultFieldValues } from 'lightning/pageReferenceUtils';
import { ShowToastEvent } from 'lightning/platformShowToastEvent';
import { refreshApex } from '@salesforce/apex';
import { getObjectInfo } from 'lightning/uiObjectInfoApi';
 
import getChildren from '@salesforce/apex/MedicalConditionsMobileCtrl.getChildren';
import getRtId from '@salesforce/apex/MedicalConditionsMobileCtrl.getRecordTypeIdByDeveloperName';
import countChildren from '@salesforce/apex/MedicalConditionsMobileCtrl.countChildren';
 
export default class MedicalRelatedListByRT extends NavigationMixin(LightningElement) {
  @api recordId;
 
  // App Builder props
  @api title = 'Related Records';
  @api childObjectApiName = 'Medical_Conditions__c';
  @api parentLookupFieldApiName = 'Account__c';
  @api recordTypeDeveloperName;
  @api newButtonLabel = 'New';
  @api maxRows = 50;
  @api viewAllTabApiName = 'Medical_View_All';
 
  // --- fieldsToShow: backed by a real reactive array (no getter in wire) ---
  _fieldNamesStr = 'Name,Medical_Conditions_Disabilities_Name__c,Allergy_Type__c,Treatment__c,Additional_Notes__c';
  @track fieldApiNames = [];
  @api
  get fieldsToShow() { return this._fieldNamesStr; }
  set fieldsToShow(v) {
    this._fieldNamesStr = v || '';
    this.fieldApiNames = this._fieldNamesStr.split(',').map(s => s.trim()).filter(Boolean);
    // Rebuild columns when fields change
    this.buildColumns(!!this.objectInfo?.data);
  }
 
  // State
  allRows = [];
  rows = [];
  columns = [];
  totalCount = 0;
  recordTypeId;
  errorMsg;
  lastLoaded = null;
  wiredChildrenResult;
  @track refreshNonce = 0;
 
  // Sorting
  sortedBy = 'Name';
  sortedDirection = 'asc';
 
  // “Updated … ago”
  @track _nowTick = Date.now();
  _timerId;
 
  // Labels metadata
  @wire(getObjectInfo, { objectApiName: '$childObjectApiName' })
  objectInfo;
 
  // Computed
  get hasCount() { return (this.totalCount || 0) > 0; }
  get itemCountText() {
    const n = this.totalCount || 0;
    return `${n} item${n === 1 ? '' : 's'}`;
  }
  get updatedAgo() {
    if (!this.lastLoaded) return '';
    const secs = Math.floor((Date.now() - this.lastLoaded) / 1000);
    if (secs < 60) return `${secs}s ago`;
    const mins = Math.floor(secs / 60);
    if (mins < 60) return `${mins} min ago`;
    const hrs = Math.floor(mins / 60);
    return `${hrs} hr ago`;
  }
  get subtitle() {
    const bits = [];
    if (this.hasCount) bits.push(this.itemCountText);
    bits.push('Filtered by Record Type');
    if (this.lastLoaded) bits.push(`Updated ${this.updatedAgo}`);
    return bits.join(' • ');
  }
  get showViewAll() { return this.totalCount > (this.rows?.length || 0); }
  get displayTitle() { return `${this.title} (${this.totalCount || 0})`; }
 
  // Lifecycle
  connectedCallback() {
    if (!this.fieldApiNames.length) {
      this.fieldApiNames = this._fieldNamesStr.split(',').map(s => s.trim()).filter(Boolean);
    }
    this.buildColumns(false); // initial columns without meta
    this._timerId = window.setInterval(() => { this._nowTick = Date.now(); }, 10000);
  }
  disconnectedCallback() {
    if (this._timerId) window.clearInterval(this._timerId);
  }
  renderedCallback() {
    if (this.objectInfo?.data && !this._columnsBuiltWithMeta) {
      this.buildColumns(true);
    }
  }
  _columnsBuiltWithMeta = false;
 
  // Columns (no functions inside objects)
  buildColumns(useMeta = false) {
    const info = useMeta ? this.objectInfo?.data : null;
    const cols = (this.fieldApiNames || []).map(f => {
      if (f === 'Name') {
        const label = info?.fields?.Name?.label || 'Name';
        return {
          label,
          fieldName: 'recordUrl',
          type: 'url',
          typeAttributes: { label: { fieldName: 'Name' }, target: '_blank' },
          cellAttributes: { class: 'slds-text-title_bold slds-text-heading_small' },
          sortable: true
        };
      }
      const label = info?.fields?.[f]?.label
        ? info.fields[f].label
        : (f.endsWith('__c') ? (f.replace('__c', '').replace(/_/g, ' ').replace(/^./, c => c.toUpperCase())) : f);
      return { label, fieldName: f, type: 'text', sortable: true };
    });
    cols.push({
      type: 'action',
      typeAttributes: { rowActions: [{ label: 'Edit', name: 'edit' }] },
      cellAttributes: { alignment: 'right' }
    });
    this.columns = cols;
    this._columnsBuiltWithMeta = !!info;
  }
 
  // Wires
  @wire(getRtId, { sobjectApiName: '$childObjectApiName', developerName: '$recordTypeDeveloperName' })
  wiredRt({ data, error }) {
    if (data !== undefined) this.recordTypeId = data || null;
    else if (error) this.errorMsg = 'Record Type lookup failed.';
  }
 
  @wire(countChildren, {
    parentId: '$recordId',
    childObjectApiName: '$childObjectApiName',
    parentLookupFieldApiName: '$parentLookupFieldApiName',
    recordTypeId: '$recordTypeId'
  })
  wiredCount({ data }) {
    if (data !== undefined) this.totalCount = data || 0;
  }
 
  @wire(getChildren, {
    parentId: '$recordId',
    childObjectApiName: '$childObjectApiName',
    parentLookupFieldApiName: '$parentLookupFieldApiName',
    fieldApiNames: '$fieldApiNames',     // <-- field, cloneable
    recordTypeId: '$recordTypeId',
    limitSize: '$maxRows',
    nonce: '$refreshNonce'
  })
  wiredChildren(result) {
    this.wiredChildrenResult = result;
    const { data, error } = result;
    if (data) {
      this.allRows = data.map(r => ({ ...r, recordUrl: '/' + r.Id }));
      this.sortedBy = 'Name';
      this.sortedDirection = 'asc';
      this.applySort();
      this.errorMsg = undefined;
      this.lastLoaded = Date.now();
      this._nowTick = Date.now();
    } else if (error) {
      this.rows = [];
      this.allRows = [];
      this.errorMsg = 'Could not fetch records.';
    }
  }
 
  // Sorting
  handleSort(event) {
    const clickedField = event.detail.fieldName;
    const field = clickedField === 'recordUrl' ? 'Name' : clickedField;
    let direction = 'asc';
    if (field === this.sortedBy) {
      direction = this.sortedDirection === 'asc' ? 'desc' : 'asc';
    }
    this.sortedBy = field;
    this.sortedDirection = direction;
    this.applySort();
  }
  applySort() {
    const field = this.sortedBy || 'Name';
    const dir = this.sortedDirection === 'desc' ? -1 : 1;
    const clone = [...this.allRows];
    clone.sort((a, b) => {
      const av = (a[field] ?? '').toString().toLowerCase();
      const bv = (b[field] ?? '').toString().toLowerCase();
      if (av === bv) return 0;
      return av > bv ? dir : -dir;
    });
    this.rows = clone;
  }
 
  // Actions
  async handleRefresh() {
    this.refreshNonce = this.refreshNonce + 1;
    if (this.wiredChildrenResult) {
      await refreshApex(this.wiredChildrenResult);
    }
    this.lastLoaded = Date.now();
    this._nowTick = Date.now();
  }
 
  handleNew() {
    // Only pass recordTypeId when present to avoid "Invalid page"
    const state = {
      defaultFieldValues: encodeDefaultFieldValues({ [this.parentLookupFieldApiName]: this.recordId })
    };
    if (this.recordTypeId) {
      state.recordTypeId = this.recordTypeId;
    } else if (this.recordTypeDeveloperName) {
      this.dispatchEvent(new ShowToastEvent({
        title: 'Record Type not ready',
        message: 'Please wait a moment and try again.',
        variant: 'warning'
      }));
      return;
    }
    this[NavigationMixin.Navigate]({
      type: 'standard__objectPage',
      attributes: { objectApiName: this.childObjectApiName, actionName: 'new' },
      state
    });
  }
 
  handleViewAll() {
    this[NavigationMixin.Navigate]({
      type: 'standard__navItemPage',
      attributes: { apiName: this.viewAllTabApiName },
      state: {
        c__parentId: this.recordId,
        c__childObjectApiName: this.childObjectApiName,
        c__parentLookupFieldApiName: this.parentLookupFieldApiName,
        c__recordTypeDeveloperName: this.recordTypeDeveloperName,
        c__fieldsToShow: this.fieldsToShow,
        c__title: this.title
      }
    });
  }
 
  handleRowAction(event) {
    const actionName = event.detail.action.name;
    const row = event.detail.row;
    if (actionName === 'edit') {
      this[NavigationMixin.Navigate]({
        type: 'standard__recordPage',
        attributes: {
          recordId: row.Id,
          objectApiName: this.childObjectApiName,
          actionName: 'edit'
        }
      });
    }
  }
}
